#!/usr/bin/env perl
# Created: 14 Nov 2018
# Author: Thomas Hackl, thackl@lim4.de
use warnings;
use strict;
use Getopt::Long  qw(:config no_ignore_case bundling);
use Data::Dumper;
use List::Util;
use Data::Dumper;
use FindBin qw($Script);
use File::Basename;
use File::Which;

use Sam::Parser 0.11;
use Sam::Alignment 0.10 ':flags';
use Sam::Seq 0.16;
use Fasta::Parser;
use Fasta::Seq;
use Fastq::Parser;
use Fastq::Seq;

GetOptions (
    "min-aln-len|a=i" => \(my $min_aln_len = 100),
    "min-ovh-len|b=i" => \(my $min_ovh_len = 100),
    "min-jnc-cov|c=i" => \(my $min_jnc_cov = 10),
    "max-ref-cov|d=i" => \(my $max_ref_cov = -1),
    "end-margins|e=i" => \(my $end_margins = 5),
    "fuzzy|f=i" => \(my $fuzzy = 0),
    "overhang-file=s" => \(my $ovh_file),
    "overhang-plus=i" => \(my $ovh_plus = 50),
    "out|o=s" => sub { '-' ne $_[1] and open(STDOUT, '>', $_[1]) || die $! },
    "help|h!" => \(my $help),
    "debug|D!" => \(my $debug),
) or die("Error in command line arguments\n");

if ($help || !@ARGV || @ARGV > 2){
    print "Usage: bam-junctions.pl bam [region] > out\n";
    printf " %-19s  %s\n", "-a/--min-aln-len", "minimum length of aligned read part [$min_aln_len]";
    printf " %-19s  %s\n", "-b/--min-ovh-len", "minimum length of read overhang (clip) [$min_ovh_len]";
    printf " %-19s  %s\n", "-c/--min-jnc-cov", "minimum read support for junction [$min_jnc_cov]";
    printf " %-19s  %s\n", "-d/--max-ref-cov", "ignore junctions with this many reads supporting the reference, -1 to disable [$max_ref_cov]";

    printf " %-19s  %s\n", "-e/--end-margins", "ignore junctions this close to sequence/region ends [$end_margins]";
    printf " %-19s  %s\n", "-f/--fuzzy", "collapse junctions this close to each other [$fuzzy]";
 
    printf " %-19s  %s\n", "--overhang-file", "write overhangs to file [".($ovh_file // "OFF")."]";
    printf " %-19s  %s\n", "--overhang-plus", "add this much aligned sequence to overhangs [$ovh_plus]";

    printf " %-19s  %s\n", "-o/--out", "write junctions to this file [STDOUT]";
    printf " %-19s  %s\n", "-h/--help", "show this help";
    printf " %-19s  %s\n", "-D/--debug", "show debug messages";
    exit 0;
}

my $bam_file = $ARGV[0];
my $bam_region = $#ARGV ? $ARGV[1] : undef;

my $samtools = "samtools";
check_binary($samtools, ["--version", "1.1"]);

if ($ovh_file) { die "Writing overhangs to file is currently not implemented" }

##----------------------------------------------------------------------------##
# make sure bam is indexed
unless ( -e $bam_file.".bai" ) { qx(samtools index $bam_file.bai); }

# init sam parser
my $sam_cmd = "$samtools view -H $bam_file |";
open(SAM, $sam_cmd) or die $!;
my $sp = Sam::Parser->new(fh => \*SAM);

# and read refernces by sequences/region
my @refs;
my %ref_lengths;
my $from_to = "";
my $rid;
if ($bam_region) {
    ($rid, $from_to) = split(":", $bam_region);
    $from_to = defined($from_to) ? ":$from_to" : "";
    while (my %h = $sp->next_header_line('@SQ')){
        next unless $h{SN} eq $rid;
        push @refs, $h{SN};
        $ref_lengths{$h{SN}} = $h{LN};
    }
}else {
    while (my %h = $sp->next_header_line('@SQ')){
        push @refs, $h{SN};
        $ref_lengths{$h{SN}} = $h{LN};
    }
    print STDERR "scanning ".@refs." sequences\n";
}


##----------------------------------------------------------------------------##
# read BAM

my $rn = @refs;
my ($rc, $ac, $sc) = 0;
my $rc5 = int(($rn/20)+.5) || 1;
my $rc5c;
my $rcl = length($rn);

if ($ovh_file) { open(OVH, ">", $ovh_file) or die $!; }

foreach my $rid (@refs){
    $rc++;
    print STDERR "processing $rid$from_to $rc/$rn\n";

    print STDERR "  extracting ";
    my ($apre, $asuf) = extract_clipped_alns($rid, $from_to);
    printf STDERR "\r  %10s %9d pre %9d suf\n", "extracted:", keys(%$apre)+0, keys(%$asuf)+0;

    if ($fuzzy){
        print STDERR "  gathering ";
        ($apre, $asuf) = gather_nearby_alns($rid, $apre, $asuf);
        printf STDERR "\r  %10s %9d pre %9d suf\n", "gathered:", keys(%$apre)+0, keys(%$asuf)+0;
    }else{
        print STDERR "  gathering ";
        ($apre, $asuf) = apply_min_cov($rid, $apre, $asuf);
        printf STDERR "\r  %10s %9d pre %9d suf\n", "gathered:", keys(%$apre)+0, keys(%$asuf)+0;
    }

    print STDERR "  filtering ";
    my $rcov;
    ($apre, $asuf, $rcov) = filter_spanned_junctions($rid, $apre, $asuf);
    printf STDERR "\r  %10s %9d pre %9d suf\n", "filtered:", keys(%$apre)+0, keys(%$asuf)+0;

    report($rid, $apre, 'pre', $rcov);
    report($rid, $asuf, 'suf', $rcov);
    
}

sub report{
    my ($rid, $ah, $label, $rcov) = @_;
    foreach my $pos (sort by_window_start keys(%$ah)) {
        my ($from, $to) = pos_from_to($pos);
        print join("\t", $rid, $from-1, $to, $pos."_".$label, @{$ah->{$pos}}+0, $rcov->{$pos}, "$rid:$from-$to"), "\n";
    }
}


if ($ovh_file){ close OVH }

#------------------------------------------------------------------------------#

sub by_window_start{
    (split("-",$a,2))[0] <=> (split("-", $b,2))[0]
}

sub pos_from_to{
    my ($from, $to) = split("-", $_[0]);
    $to//=$from;
    return($from, $to);
}

# Gather alignments with clipped ends satisfying option cutoffs by position in a
# prefix and a suffix hash
sub extract_clipped_alns{
    my ($rid, $from_to) = (@_, "");
    my %apre; my %asuf;

    # filter unmapped or secondary
    open(SAM, "$samtools view -F 260 $bam_file $rid$from_to |") or die $!;
    my $sp = Sam::Parser->new(fh => \*SAM);
    while(my  $aln = $sp->next_aln()){
        $ac++;
        print STDERR "." unless $ac % 1000;
        
        # ignore non trimmed reads
        my ($pre) = $aln->cigar =~ /^(\d+)[SH]/;
        my ($suf) = $aln->cigar =~ /(\d+)[SH]$/;
        next unless $pre || $suf;
        next if $aln->length < $min_aln_len;
        if ($pre && $aln->pos <= $end_margins){ $pre = undef};
        if ($suf && $aln->pos + length($aln->seq_aligned) >= $ref_lengths{$rid}-$end_margins){ $suf = undef};
        
        push @{$apre{$aln->pos}}, $aln if $pre && $pre >= $min_ovh_len;
        push @{$asuf{$aln->pos + length($aln->seq_aligned) -1 }}, $aln if $suf && $suf >= $min_ovh_len;
    }
    return(\%apre,\%asuf);
}

sub apply_min_cov{
    my ($rid, $apre, $asuf) = @_;
    for my $ah ($apre, $asuf) {
        my @delete;
        while (my ($k, $v) = each %$ah) {
            push @delete, $k if @$v < $min_jnc_cov;
        }
        delete($ah->{$_}) for @delete;
    }
    return($apre, $asuf);
}

# Merge alns close to each other into "same" position
sub gather_nearby_alns{
    my ($rid, $apre, $asuf) = @_;
    for my $ah ($apre, $asuf) {
        # windowed filter for regions of interest
        my @pos = sort{$a<=>$b}keys %$ah;
        next unless @pos; # no clips
        my @along = (0) x $ref_lengths{$rid};
        @along[@pos] = map{scalar @$_}@{$ah}{@pos};
        my %above;
        # run along ref pos and find windows above threshold
        my $sum = sum(@along[0..$fuzzy-1]);
        $above{1} = $sum if $sum >= $min_jnc_cov;
        for (my $i=1; $i<@along-$fuzzy; $i++) {
            $sum = $sum-$along[$i]+$along[$i+$fuzzy];
            $above{$i+1} = $sum if $sum >= $min_jnc_cov;
            $above{$i+$fuzzy} = $sum if $sum >= $min_jnc_cov;
        }

        while (my $k = each %$ah) {
            delete $ah->{$k} unless exists $above{$k};
        }

        # collapse adjacent positions
        my @above = sort{$a<=>$b}keys %$ah;
        next unless @above >1; # need at least two pos for collapse
        my @collapsed = ([$above[0]]); # nested structure
        for (my $i=1;$i<@above;$i++) {
            if ($above[$i] <= $above[$i-1]+$fuzzy) {
                push @{$collapsed[-1]}, $above[$i];
            }else {
                push @collapsed, [$above[$i]];
            }
        }
        my %collapsed ;
        foreach (@collapsed) {
            @pos = @$_;
            my $win = @pos > 1 ? "$pos[0]-$pos[$#pos]" : $pos[0];
            $collapsed{$win} = [map{@{$ah->{$_}}}@pos];
        }
        $ah = \%collapsed;
    }
    return($apre,$asuf)
}

sub sum{
    my $s = 0;
    $s+= $_ for @_;
    return $s;
}


# get reads spanning the junction
sub filter_spanned_junctions{
    my ($rid, $apre, $asuf) = @_;
    my %rcov;
    for my $ah ($apre, $asuf) {
        my %cov;

        
        foreach my $pos(keys %$ah) {
            my ($from, $to) = pos_from_to($pos);
            $cov{$from} = {pos => $pos, to => $to, cov => 0};
        }

        # filter unmapped or secondary
        open(SAM, "$samtools view -F 260 $bam_file $rid$from_to |") or die $!;
        my $sp = Sam::Parser->new(fh => \*SAM);
        my $ac=0;
        while(my  $aln = $sp->next_aln()){
            print STDERR "." unless ++$ac % 1000;
            my ($s, $e) = ($aln->pos + 30, $aln->pos + length($aln->seq_aligned) - 30);
            for ($s..$e){
                if (exists($cov{$_}) && $cov{$_}{to} < $e){
                    $cov{$_}{cov}++;
                }
            }
        }
        
        while (my ($k,$v) = each %cov) {
            if($max_ref_cov > -1 && $v->{cov} > $max_ref_cov){
                delete($ah->{$v->{pos}}) 
            }else {
                $rcov{$v->{pos}} = $v->{cov};  
            }
        }

        # my @delete;
        # my $pos_n = keys %$ah;
        # my $pos_i = 0;
        # my $regions = join(" ", map{"$rid:".join("-", pos_from_to($_))}keys %$ah);
        # my $tmp_bam = "tmp_".$bam_file;
        # qx(samtools view -b $bam_file $regions | samtools sort -o $tmp_bam; samtools index $tmp_bam);
        # foreach my $pos (keys %$ah) {
        #     my ($from, $to) = pos_from_to($pos);
        #     my $jp = Sam::Parser->new(
        #         file => $tmp_bam,
        #         region=>"$rid:$from-$to",
        #         is => sub{! $_[0]->is(SECONDARY) }
        #     );
        #     $pos_i++;
        #     print "\r$pos_n/$pos_i";
            
        #     my $ref_cov = 0;
        #     while (my n = $jp->next_aln) {
        #         $ref_cov++ if ($aln->pos < $from-30-$fuzzy) && ($aln->pos + $aln->length > $to+30+$fuzzy);
        #     }
        #     push @delete, $pos if $ref_cov > $max_ref_cov;
        #     $rcov{$pos} = $ref_cov;
        # }
        # delete($ah->{$_}) for @delete;
        # print "\n";
    }
    return($apre, $asuf, \%rcov);
}




=head2 check_binary

Check whether a required binary (and version) exists.

=cut

sub check_binary{
    my($bin, $ver) = (@_);
    my $fbin = $bin;
    unless(-e $fbin && -x $fbin){
        if ($fbin = which($bin)) {
            die("Binary '$fbin' not executable") unless -e $fbin && -x $fbin;
        } else {
            die("Binary '$bin' neither in PATH nor executable");
        }
    }

    $bin = basename($fbin);

    my $v;
    if ($ver) {
        die("ARRAY ref required") unless ref $ver eq "ARRAY";

        my $vs = qx($fbin $ver->[0]);
        if ($? or ! $vs) {
            die("Couldn't determine version of $bin, at least $ver->[1] required");
        }

        ($v) = $vs =~ /(\S+?)\D*$/m;

        if (version->declare($v) < version->declare($ver->[1])) {
            die("Version $v of '$bin' < $v");
        }

    }

    printf STDERR "  [ok] %-15s %s\n", $bin.($v ? "-$v" : ""), dirname($fbin);

}
